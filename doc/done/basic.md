```md
# Done:
- [x] Function Definition (proc)
  - [x] Main function
  - [x] Static/Extern
  - [x] varargs
    - [_] ... operator   (@note cant. parsing `..` alone breaks the syntax. needs to be ...args or similar)
    - [x] varargs keyword
- [x] Control Flow
  - [x] Keywords
    - [x] return
    - [x] break
    - [x] continue
  - [x] While
  - [x] For loops
    - [x] Basic support
  - [x] Switch case
    - [x] case ... of:
    - [x] else: == default:
    - [x] Mandatory explicit fallthrough, otherwise (break;) auto
- [x] Variable definition:
  - [x] Immutable : Let/Const
  - [x] Mutable   : Var
  - [x] Variable asignment
  - [x] Tentative variable definition
  - [x] Top-level  (Static/Extern)
  - [x] {.persistent.}  (aka static memory)  https://modelingwithdata.org/arch/00000070.htm
  - [x] `{.readonly.}` without explicit typedef
- [ ] Values and Literals
  - [x] Char : Resolve to 'c'
  - [x] Ints
  - [x] Floats
    - [x] 0.0f suffix for floats
    - [x] 0.0L suffix for float128
    - [x] no-suffix for doubles (default in C)
  - [x] Strings
    - [x] Raw
    - [x] Normal
    - [x] Multi-line
      - [x] Raw      raw"""..."""
      - [x] NewLine     """..."""
  - [x] Arrays
    - [x] Sized
    - [x] Unknown size  one :array[_,char]   ->   char one[]
    - [x] Initialization
    - [x] Designated Initialization
    - [x] indexed access
- [x] Modules (include/import) and Namespacing
  - [x] Include keyword
    - [x] Global
    - [x] Local
    - [x] .c files
  - [x] Header Include Guards
    - [x] {.pragma:once.}   #pragma once
- [x] Standalone Pragmas
  - [x] {.error:"msg".}
  - [x] {.define: name.}, {.define: name[sym]value.} and {.define: name [sym]value.}
  - [x] {.pragma:once.}
- [x] Doc Comments
- [x] Function calls
  - [x] Call(syntax)
  - [x] command syntax
  - [x] addr
- [x] Conditions
  - [x] Sketch   : Single condition only
  - [x] Ternary operator   let one = if condition: 1 else: 2
  - [x] if/elif/else blocks
  - [x] Multi-condition support (recursive)
  - [x] when defined(symbol)
  - [x] Operators:  (and,&&) (or,||) (&,&) (|,|)
  - [x] Arbitrary condition tree support
- [x] Operators
  - [x] Prefix   + - & ! * -- ++
  - [x] Infix
    - [x] Arithmetic : + - * / %
    - [x] Bitwise    : & | << >>
    - [x] Asignment  : += -= *= /= %=  |= ^= ~=   <<= >>=
    - [x] Logical    : && || == != < > <= >=
    - [x] Postfix    : ++ --  (nim parser has no postfix, other than * for visibility)
    - [x] obj->field   pointer access syntax ->
- [x] Type declaration
  - [x] Type aliasing   typedef char* str;
  - [x] {.readonly.}    Mutable pointer to immutable data
- [x] Explicit casting
  - [x] cast[T](...) syntax
  - [x] Alternative syntax
    - [x] val as Type
    - [x] val @ Type
- [x] Pointer dereference   one[] = val   ->   *one = val
- [x] Types
  - [x] Structs
    - [x] Declaration
    - [x] Definition
    - [x] Designated Initialization
    - [x] Field access
      - [x] Value access    thing.sub
      - [x] Pointer access  thing->sub
    - [x] {.stub.} for using the non-typedef version of the struct
    - [x] Compound Literals
    - [x] Construction: Function Parameters
    - [x] Construction: Reassignment
  - [x] Procs
  - [x] Multi-word types  (eg: unsigned T)
    - [x] signed
    - [x] unsigned
    - [x] long
    - [x] short
    - [x] double, triple and quadruple worded types
    - [x] Multi-word pointer types  (eg: ptr unsigned long long int)
  - [x] Enums
    - [x] Implicit values
    - [x] Field Prefixes
    - [x] Explicit values
    - [x] {.unsafe.} pragma    Skips prefixing the values with the type
    - [x] {.pure.} for fields  Adds prefix even inside {.unsafe.} enums
  - [x] Unions
```

